import numpy as np
import matplotlib.pyplot as plt

#Details
t_max = 0.2  # simulation time in seconds
dt = 0.001  # step size
N = 64 # Number of particles
D = 0.1  # diffusivity
Nx = 64 #Euler grid size
ones = np.ones(N)  # Array of ones for where function
zeros = np.zeros(N)  # Array of zeros for where function
blue = np.full(N, 'b')  # Array of blue for where function
red = np.full(N, 'r')  # Array of red for where function

# Domain size
x_min = -1
x_max = 1

ref = np.genfromtxt('reference_solution_1D.dat')
x = np.random.uniform(x_min, x_max, size=N)  # initial x-positions
phi = np.where(x <= 0, ones, zeros)

print(np.around(x,decimals = 2))
print(phi)

for i in np.arange(0, t_max, dt):
    x += np.sqrt(2 * D * dt) * np.random.normal(0, 1, size=N)

print(np.around(x,decimals = 2))
phi = np.where(x <= 0, ones, zeros)
phi_splits = np.array_split(phi, Nx)

print(phi_splits[0])

x, phi = zip(*sorted(zip(x,phi)))

plt.plot(ref[:, 0], ref[:, 1], color='g')
plt.plot(x, phi, color='b')
plt.show()

# x_gran = np.round((x - x_min) / (x_max - x_min) * (Nx - 1)).astype(int)
# print(x_gran)
# unq, ids, count = np.unique(x_gran, return_inverse=True, return_counts=True, axis=0)        
# print(unq, ids, count)


# def getavrphimesh():
#     x_gran = np.round((x - x_min) / (x_max - x_min) * (Nx - 1)).astype(int)  
#     unq, ids, count = np.unique(x_gran, return_inverse=True, return_counts=True, axis=0)        
#     avrphi = np.bincount(ids, phi) / count
#     return avrphi

# for i in np.arange(0, t_max, dt):
#     #avphi = getavrphimesh()
#     plt.plot(ref[:, 0], ref[:, 1], color='g')
#     # plt.scatter(np.linspace(x_min, x_max, Nx), avphi[0], s=15, marker='.', color='b')
#     # plt.plot(np.linspace(x_min, x_max, Nx), avphi[0], color='b')
#     # plt.show()
#     x += np.sqrt(2 * D * dt) * np.random.normal(0, 1, size=N)
#     print(x)